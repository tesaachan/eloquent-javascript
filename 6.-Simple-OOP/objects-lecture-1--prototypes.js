// Тайная жизнь объектов

// Инкапсуляция

// идея в том, чтобы разделить программу на мелкие части, которые будут управлять
// своим состоянием
// т.е. некоторые знания о работе программы хранятся в ней локально.
// Всякий раз, когда локальные детали обновляются, должен обновляться код, 
// имеющий к ним отношение.

// Части такой программы взаимодействуют посредством интерфейсов -
// ограниченных наборов функций - предоставляющих полезную функциональность
// на более абстрактном уровне, скрывая подробности реализации, определяющих
// отношение между объектами

// Свойства, являющиеся частью интерфейса - общедоступны.
// Другие - закрытые.

// В JS нет реализации закрытых свойств, поэтому закрытые свойства принято
// начинать с "_" и указывать об этом в комментариях.


// Методы

// Методы - свойста, содержащие функциональные значения

let rabbit = {};
rabbit.speak = function(line) {
	console.log(`Rabbit says: '${line}'`);
};
rabbit.speak("I'm alive");

// В теле метода существует привязка this, указывающая на объект,
// для которого была вызвана функция:

function speak(line) {
	console.log(`${this.type} rabbit says '${line}'`);
}
let whiteRabbit = {type: "white", speak};
let hungryRabbit = {type: "hungry", speak};

whiteRabbit.speak("sayonara" + "boooooy");
// white rabbit sasys: 'sayonara boooooy'

// если вы хотите передать привязку this явно, то используется
// метод функции call, он принимает this в качестве первого аргумента,
// а остальные аргументы как обычные параметры

speak.call(hungryRabbit, "too many food");
// hungry rabbit says 'too many food'

// на this нельзя ссылаться в области видимости обычной функции, не метода.

// У стрелочных функций нет собственных объектов this, однако они
// могут видеть this из области видимости:

function normalize() {
	console.log(this.coords.map(n => n / this.length));
}

normalize.call({coords: [0, 2, 3], length: 5}); // [0, 0.4, 0.6]

// если бы аргумент для map был написан через function, то код не работал бы


// Прототипы

let empty = {};
console.log(empty.toString); // function toString()...{}
console.log(empty.toString()); // [object Object]

// сейчас было вытащино свойство из пустого объекта.
// Кроме набора свойств, у большинства объектов также есть прототип.

// Прототип - это другой объект, запасной источник свойств.
// Когда объект получает запрос на поиск свойств, которых у него нет,
// поиск будет выполнен в его прототипе, затем в прототипе прототипа и т.д.
// Все объекты происходят от: Object.prototype

Object.getPrototypeOf({}) == Object.prototype; // true
Object.getPrototypeOf(Object.prototype); // null

// метод Object.getPrototypeOf возвращает прототип объекта.

// Взаимосвязь объектов образует древовидную структуру, и корень в ней -
// Object.prototype

// Функции наследуются от Function.prototype, массивы - от Array.prototype.

Object.getPrototypeOf(Math.max) == Function.prototype; // true

// прототипом таких прототипов является Object.prototype.

// Для создания объекта с конкретным прототипом используется Object.create:

let protoRabbit = {
	speak(line) {
		console.log(`${this.type} rabbit says: '${line}'`);
	}
};
let killerRabbit = Object.create(protoRabbit);
killerRabbit.type = "angry";
killerRabbit.speak("I'll kill you");
// angry rabbit says 'I'll kill you'

// Свойства подобные speak в объектном выражении являются кратким
// способом определения методов. Создается свойство, значением которого
// будет функция.

// protoRabbit играет роль контейнера для свойств, общих для всех кроликов.
// Конкретный объект содержит свойства, присущие только ему, и наследует
// общие свойства от прототипа.
