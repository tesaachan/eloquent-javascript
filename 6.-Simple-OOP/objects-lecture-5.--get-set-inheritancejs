// Геттеры, сеттеры и статические методы

// Интерфейсы главным образом состоят из методов, но они также 
// могут включать в себя нефункциональные свойства.

// Например, объект Map содержит свойство size, содержащее количество ключей.

// Подобным объектам нет необходимости вычислять и хранить такие свойства
// в экземплярах.

// Такие свойства обладают вызов метода - геттера.
// Такой метод определяется словом get перед именем метода:

let varyingSize = {
	get size() {
		return Math.floor(Math.random() * 100);
	}
}
console.log(varyingSize.size); // 73
console.log(varyingSize.size); // 49

// Каждый раз при чтении содержимого свойства size такого объекта,
// вызывается связанный метод.

// Подобный метод для записи - сеттер:

class Temperature {
	constructor(celsius) {
		this.celsius = celsius;
	}
	get fahrenheit() {
		return this.celsius * 1.8 + 32;
	}
	set fahrenheit(value) {
		this.celsius = (value - 32) / 1.8
	}
	static fromFahrenheit(value) {
		return new Temperature((value - 32) / 1.8);
	}
}

let temp = new Temperature(22);
console.log(temp.fahrenheit); // 71.6
temp.fahrenheit = 86;
console.log(temp.celsius); // 30

// Температуру можно записывать и получать в двух системах, но внутри она
// хранится только в градусах Цельсия, а преобразование выполняется
// автоматически при обращении.

// Статические static методы хранятся в конструкторе,
// т.е. класс Temperature позволяет написать Temperature.fromFahrenheit(100),
// чтобы получить температуру в градусах Фаренгейта.


// Наследование

// Симметричные матрицы - одинакова относительно диагонали,
// значение ячейки x,y всегда совпадает со значением y,x
// Предположим, нам нужна структура как Matrix, но гарантирующая симметричность.

// Система прототипов JS позволяет создать новый класс на основе старого:
// прототип нового класса происходит от старого прототипа, но в него можно
// добавить новое определение

class SymmetricMatrix extends Matrix {
	constructor(size, element = (x, y) => undefined) {
		super(size, size, (x, y) => {
			if (x < y) return element(y, x);
			else return element(x, y);
		});
	}

	set(x, y, value) {
		super.set(x, y, value);
		if (x != y) {
			super.set(y, x, value);
		}
	}
}

let matrix = new SymmetricMatrix(5, (x, y) => `${x}, ${y}`);
console.log(matrix.get(2, 3)); // 3, 2

// Слово extends указывает на то, что данный класс основан не на прототипе Object,
// а на другом классе - суперклассе.
// Производный класс - подкласс.

// Чтобы инициализировать экземпляр SymmetricMatrix, его конструктор вызывает
// конструктор суперкласса через ключевое слово super.
// Это необходимо.
// Для обеспечения симметричности конструктор оборачивает функцию element,
// чтобы поменять местами координаты и получить значение ниже диагонали.

// В set снова применяется super, но здесь для вызова конкретного метода из
// множества методов суперкласса.
// Переопределяя метод set, мы хотим использовать исходное поведение этого метода.

// Поскольку this.set ссылается на новый set, такой вызов не будет работать.

// super позволяет вызывать методы так, как если бы они были определены в суперклассе.

// Чрезмерное использование наследия приводит к путанице, так как 
// для определения подкласса нужно знать механизмы работы суперкласса,
// что усложняет программу.


// Оператор instanceof

// Бинарный оператор instanceof возвращает true, если переданный объект
// является производным от определённого класса.

console.log(new SymmetricMatrix(2) instanceof SymmetricMatrix); // true
console.log(new SymmetricMatrix(2) instanceof Matrix); // true
console.log(new Matrix(2, 2) instanceof SymmetricMatrix); // false
console.log([1] instanceof Array); // true

// Оператор также может быть применён к стандартным конструкторам,
// таким как Array.
