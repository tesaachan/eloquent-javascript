// Словари

// Словарь - структура данных, которая связывает значения (ключи) 
// с другими значениями. Например, сопоставляя имена и возраст.

// Для этого можно использовать объекты:

let ages = {
	Boris: 39,
	Lee: 22,
	Julia: 62
};

console.log(`Юлии ${ages["Julia"]}`);
console.log("Знаем ли мы, сколько лет Джеку?", ("Jack" in ages) ? "Да" : "Нет");

// Использовать простые объекты в словаре опасно из-за наследуемых от
// Object.prototype свойств:

"toString" in ages // true

// Однако, в JS есть класс Map, который написан специально для такой
// структуры данных.
// Он хранит отображения и позволяет задействовать любые типы ключей.

let ages = new Map();
ages.set("Boris", 39);
ages.set("Lee", 22);
ages.set("Julia", 62);

console.log(`Юлии ${ages.get("Julia")}`);
console.log("Знаем ли мы, сколько лет Джеку?", (ages.has("Jack")) ? "Да" : "Нет");
console.log(ages.has("toString")); // false

// Объект Map имеет методы set, get и has.

// Для простого объекта важно (!) знать, что Object.keys возвращает только
// собственные ключи, а не ключи из прототипа.
// В качестве альтернативы оператору in можно использовать метод
// hasOwnProperty, который игнорирует прототип объекта.

console.log({x: 1}.hasOwnProperty("x")); // true
console.log({x: 1}.hasOwnProperty("toString")); // false
console.log("toString" in {x: 1}); // true


// Полиморфизм

// Если часть кода написана для работы с объектами, имеющими определённый
// интерфейс - в данном случае метод toString, - то любой объект,
// поддерживающий данный интерфейс может быть вставлен в код и он будет работать

Rabbit.prototype.toString = function() {
	return `${this.type} rabbit`;
};

console.log(String(blackRabbit)); // black rabbit

// Подобная методика - полиморфизм. Полиморфный код может работать со значениями
// разных видов, если они поддерживают ожидаемый интерфейс.

// Например, цикл for/of позволяет перебирать разные структуры данных.
// Это ещё один случай полиморфизма - такие циклы ожидают, что структура
// предоставляет определённый интерфейс, как у массивов и строк.


// Символы

// Символы есть значения, созданные с помощью функции Symbol.
// В отличие от строк, символы уникальны, нельзя создавать одинаковые дважды:

let sym = Symbol("name");
console.log(sym == Symbol("name")); // false
Rabbit.prototype[sym] = 55;
console.log(blackRabbit[sym]); // 55

// Символы могут быть именами свойств.
// Строка, передаваемая в Symbol, используется при преобразовании ее в строку
// и может упростить распознавание символа.

// Благодаря уникальности и удобству символы хорошо подходят для определения
// интерфейсов, сосуществующими с другими свойствами, независимо от их имён.

const toStringSymbol = Symbol("toString");
Array.prototype[toStringSymbol] = function() {
	return `${this.length} см голубой шерсти`;
}

[1, 2].toString(); // 1,2
[1, 2][toStringSymbol](); // 2 см голубой шерсти

// Т.е. чтобы включить свойства символа в выражения объекта и класса,
// нужно заключить имя свойства в квадратные скобки.
// Тогда имя свойства будет вычислено по привязке содержащей символ.

let stringObject = {
	[toStringSymbol]() { return "something"; }
};
console.log(stringObject[toStringSymbol]()); //something
